迭代器允许访问容器的元素。若使用begin和end迭代器，则有一个可以进一步处理的范围。对于容器cont，使用cont.begin()获得开始迭代器，使用cont.end()获得结束迭代器，其定义了半开范围。因为开始迭代器属于范围，所以是半开的，而结束迭代器指向范围之外的位置。迭代器对cont.begin()和cont.end()使其能够修改容器的元素。

\begin{center}
创建和删除容器
\end{center}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{迭代器}               & \textbf{描述}                         \\ \hline
\endfirsthead
%
\endhead
%
cont.begin() and cont.end()     & 向前迭代的一对迭代器。        \\ \hline
cont.cbegin() and cont.cend()   & 用于向前const迭代的一对迭代器。  \\ \hline
cont.rbegin() and cont.rend()   & 一对向后迭代的迭代器。       \\ \hline
cont.crbegin() and cont.crend() & 一对迭代器，用于向后const迭代。 \\ \hline
\end{longtable}

现在可以修改容器了。

\filename{访问容器的元素}

\begin{cpp}
// containerAccess.cpp
...
#include <vector>
...
struct MyInt{
	MyInt(int i): myInt(i){};
	int myInt;
};

std::vector<MyInt> myIntVec;
myIntVec.push_back(MyInt(5));
myIntVec.emplace_back(1);
std::cout << myIntVec.size() << '\n'; // 2

std::vector<int> intVec;
intVec.assign({1, 2, 3});
for (auto v: intVec) std::cout << v << " "; // 1 2 3

intVec.insert(intVec.begin(), 0);
for (auto v: intVec) std::cout << v << " "; // 0 1 2 3

intVec.insert(intVec.begin()+4, 4);
for (auto v: intVec) std::cout << v << " "; // 0 1 2 3 4

intVec.insert(intVec.end(), {5, 6, 7, 8, 9, 10, 11});

for (auto v: intVec) std::cout << v << " "; // 0 1 2 3 4 5 6 7 8 9 10 11

for (auto revIt= intVec.rbegin(); revIt != intVec.rend(); ++revIt)
	std::cout << *revIt << " "; // 11 10 9 8 7 6 5 4 3 2 1 0

intVec.pop_back();
for (auto v: intVec ) std::cout << v << " "; // 0 1 2 3 4 5 6 7 8 9 10
\end{cpp}















