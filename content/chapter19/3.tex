
要使用C++的多线程接口，需要头文件<thread>。C++11中支持std::thread，C++20中支持改进的std::jthread。

\mySamllsection{std::thread}

\mySamllsection{创建}

线程std::thread表示一个可执行单元。线程立即启动的可执行单元将其工作包作为可调用单元。可调用单元可以是函数、函数对象或Lambda函数:

\filename{创建线程}

\begin{cpp}
// threadCreate.cpp
...
#include <thread>
...
using namespace std;

void helloFunction(){
	cout << "function" << endl;
}

class HelloFunctionObject {
public:
	void operator()() const {
		cout << "function object" << endl;
	}
};

thread t1(helloFunction); // function

HelloFunctionObject helloFunctionObject;
thread t2(helloFunctionObject); // function object

thread t3([]{ cout << "lambda function"; }); // lambda function
\end{cpp}

\mySamllsection{生命周期}

The creator of a thread has to take care of the lifetime of its created thread. The executable unit of the created thread ends with the end of the callable. Either the creator is waiting until the created thread t is done (t.join()) or the creator detaches itself from the created thread: t.detach(). A thread t is joinable if no call t.join() or t.detach() was performed on it. A joinable thread throws in its destructor the exception std::terminate, and the program terminates.

\filename{线程的生命周期}

\begin{cpp}
// threadLifetime.cpp
...
#include <thread>
...

thread t1(helloFunction); // function

HelloFunctionObject helloFunctionObject;
thread t2(helloFunctionObject); // function object

thread t3([]{ cout << "lambda function"; }); // lambda function

t1.join();
t2.join();
t3.join();
\end{cpp}

A from its creator detached thread is typically called a daemon thread because it runs in the background.

\begin{myWarning}{小心移动线程}
Threads can be moved but not copied.

\begin{cpp}
#include <thread>
...
std::thread t([]{ cout << "lambda function"; });
std::thread t2;
t2 = std::move(t);

std::thread t3([]{ cout << "lambda function"; });
t2 = std::move(t3); // std::terminate
\end{cpp}

By performing t2 = std::move(t) thread t2 gets the callable of thread t. Assuming thread t2 already had a callable and is joinable, the C++ runtime would call std::terminate. This happens exactly in t2 = std::move(t3) because t2 neither executed t2.join() nor t2.detach() before.
\end{myWarning}

\mySamllsection{参数}

A std::thread is a variadic template. This means that it can get an arbitrary number of arguments by copy or reference. Either the callable or the thread can get the arguments. The thread delegates them to the callable: tPerCopy2 and tPerReference2.

\begin{cpp}
#include <thread>
...

using namespace std;

void printStringCopy(string s){ cout << s; }
void printStringRef(const string& s){ cout << s; }

string s{"C++"};

thread tPerCopy([=]{ cout << s; }); // C++
thread tPerCopy2(printStringCopy, s); // C++
tPerCopy.join();
tPerCopy2.join();

thread tPerReference([&]{ cout << s; }); // C++
thread tPerReference2(printStringRef, s); // C++
tPerReference.join();
tPerReference2.join();
\end{cpp}

The first two threads get their argument s by copy, the second two by reference.

\begin{myWarning}{默认情况下，线程应该通过复制获得参数}
\filename{线程的参数}
	
\begin{cpp}
// threadArguments.cpp
...
#include <thread>
...

using std::this_thread::sleep_for;
using std::this_thread::get_id;

struct Sleeper{
	Sleeper(int& i_):i{i_}{};
	void operator() (int k){
		for (unsigned int j= 0; j <= 5; ++j){
			sleep_for(std::chrono::milliseconds(100));
			i += k;
		}
		std::cout << get_id(); // undefined behaviour
	}
	private:
	int& i;
};

int valSleeper= 1000;

std::thread t(Sleeper(valSleeper), 5);
t.detach();

std::cout << valSleeper; // undefined behaviour
\end{cpp}

This program snippet has undefined behavior. First, the lifetime of std::cout is bound to the lifetime of the main thread, and the created thread gets its variable valSleeper by reference. The issue is that the created thread could live longer than its creator, therefore, std::cout and valSleeper lose their validity if the main thread is done. Second, valSleeper is a shared, mutable variable which is concurrently used by the main thread and the child thread. Consequently, this is a data race.
\end{myWarning}

\mySamllsection{操作}

You can perform many operations on a thread t.

\begin{center}
Operations with a std::thread
\end{center}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{成员函数}                                                   & \textbf{描述}                                      \\ \hline
\endfirsthead
%
\endhead
%
t.join()                                                                   & Waits until thread t has finished its executable unit.    \\ \hline
t.detach()                                                                 & Executes the created thread t independent of the creator. \\ \hline
t.joinable()                                                               & Checks if thread t supports the calls join or detach.     \\ \hline
\begin{tabular}[c]{@{}l@{}}t.get\_id() and\\ std::this\_thread::get\_id()\end{tabular} & Returns the ideentity of the thread. \\ \hline
std::thread::hardware\_concurrency()                                       & Indicates the number of threads that can run in parallel. \\ \hline
std::this\_thread::sleep\_until(absTime)                                   & Puts the thread t to sleep until time absTime.            \\ \hline
std::this\_thread::sleep\_for(relTime)                                     & Puts the thread t to sleep for the duration relTime.      \\ \hline
std::this\_thread::yield()                                                 & Offers the system to run another thread.                  \\ \hline
\begin{tabular}[c]{@{}l@{}}t.swap(t2) and\\ std::swap(t1, t2)\end{tabular} & Swaps the threads.                                        \\ \hline
\end{longtable}

You can only call t.join() or t.detach() once on a thread t. If you attempt to call these more than once, you get the exception std::system\_error. std::thread::hardware\_concurrency returns the number of cores or 0 if the runtime cannot determine the number. The sleep\_until and sleep\_for operations need a time point or a time duration as an argument.

Threads cannot be copied but can be moved. A swap operation performs a move when possible.

\filename{线程上的操作}

\begin{cpp}
// threadMember Functions.cpp
...
#include <thread>
...
using std::this_thread::get_id;

std::thread::hardware_concurrency(); // 4

std::thread t1([]{ get_id(); }); // 139783038650112
std::thread t2([]{ get_id(); }); // 139783030257408
t1.get_id(); // 139783038650112
t2.get_id(); // 139783030257408

t1.swap(t2);

t1.get_id(); // 139783030257408
t2.get_id(); // 139783038650112
get_id(); // 140159896602432
\end{cpp}

\mySamllsection{std::jthread}

std::jthread stands for joining thread. In addition to std::thread from C++11, std::jthread can automatically join the started thread and signal an interrupt.

\mySamllsection{自动汇入}

The non-intuitive behavior of std::thread is the following: when a std::thread is still joinable, std::terminate is called in its destructor.

On the contrary, a std::jthread thr automatically joins in its destructor if thr is still joinable.

\filename{终止一个仍然可汇入的std::jthread}

\begin{cpp}
// jthreadJoinable.cpp
...
#include <thread>
...

std::jthread thr{[]{ std::cout << "std::jthread" << "\n"; }}; // std::jthread

std::cout << "thr.joinable(): " << thr.joinable() << "\n"; // thr.joinable(): true
\end{cpp}

除了std::thread之外，std::jthread也是可中断的。














