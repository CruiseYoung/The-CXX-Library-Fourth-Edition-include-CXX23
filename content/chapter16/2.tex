
流类std::istream和std::ostream通常用于数据的读写。使用std::istream类需要<istream>头文件;使用std::ostream类需要<ostream>头文件。你可以同时使用<iostream>头文件。std::istream分别是类basic\_istream和类basic\_ostream的字符类型char, std::ostream的类型定义:

\begin{cpp}
typedef basic_istream<char> istream;
typedef basic_ostream<char> ostream;
\end{cpp}

为了方便处理键盘和显示器，C++有四个预定义的流对象。

\begin{center}
四个预定义的流对象
\end{center}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|l|l|}
\hline
\textbf{流对象} & \textbf{C} & \textbf{设备} & \textbf{是否缓冲} \\ \hline
\endfirsthead
%
\endhead
%
std::cin               & stdin              & keyboard        & yes               \\ \hline
std::cout              & stdout             & console         & yes               \\ \hline
std::cerr              & stderr             & console         & no                \\ \hline
std::clog              &                    & monitor         & yes               \\ \hline
\end{longtable}


\begin{myNotic}{流对象也可用于wchar\_t}
到目前为止，wchar\_t、std::wcin、std::wcout、std::wcerr和std::wclog的四个流对象并没有像它们的字符那样大量使用。这里，只是稍微提一下。
\end{myNotic}

流对象足以编写从命令行读取并返回总和的程序。

\filename{流对象}

\begin{cpp}
// IOStreams.cpp
...
#include <iostream>

int main(){
	std::cout << "Type in your numbers";
	std::cout << "(Quit with an arbitrary character): " << std::endl;
				// 2000 <Enter> 11 <a>
	int sum{0};
	int val;
	while (std::cin >> val) sum += val;
	std::cout << "Sum: " << sum; // Sum: 2011
}
\end{cpp}

上面的小程序使用了流操作符<{}<和>{}>，以及流操纵符std::endl。

插入操作符<{}<将字符压入输出流std::cout;提取操作符>{}>从输入流std::cin中提取字符。可以构建插入或提取操作符链，这两个操作符都返回对自己的引用。

std::endl是一个流操纵符，因为它将一个'\verb|\|n'字符放到std::cout上，并刷新输出缓冲区。

下面是最常用的流操纵符。

\begin{center}
最常用的流操纵符
\end{center}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|l|}
\hline
\textbf{操纵符} & \textbf{流类型} & \textbf{描述}                                 \\ \hline
\endfirsthead
%
\endhead
%
std::endl            & output               & 插入新行字符并刷新流。 \\ \hline
std::flush           & output               & 刷新流。                                  \\ \hline
std::ws              & input                & 丢弃前置空格。                         \\ \hline
\end{longtable}

\mySamllsection{输入}

C++中，从输入流中读取数据有两种方式:用提取器>{}>格式化和用显式成员函数不格式化。

\mySamllsection{格式化输入}

提取操作符>{}>

\begin{itemize}
\item 
为所有内置类型和字符串预定义，

\item 
可为用户定义的数据类型进行实现，

\item 
可以通过格式说明符进行配置。
\end{itemize}

\begin{myTip}{默认情况下，std::cin会忽略前置空格}
\begin{cpp}
#include <iostream>
...
int a, b;
std::cout << "Two natural numbers: " << '\n';
std::cin >> a >> b; // < 2000 11>
std::cout << "a: " << a << " b: " << b;
\end{cpp}
\end{myTip}

\mySamllsection{非格式化输入}

对于来自输入流的未格式化输入，有许多成员函数。

\begin{center}
来自输入流的未格式化输入
\end{center}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{成员函数}                          & \textbf{描述}                                                                 \\ \hline
\endfirsthead
%
\endhead
%
is.get(ch)                                        & 将一个字符读入ch。                                                         \\ \hline
is.get(buf, num)                                  & 在缓冲区中最多读取num个字符。                                    \\ \hline
is.getline(buf, num{[}, delim{]}) &
\begin{tabular}[c]{@{}l@{}}在缓冲区中最多读取num个字符。\\ 可选地使用行分隔符delim(默认\textbackslash{}n)。\end{tabular} \\ \hline
is.gcount()                                       & 返回通过未格式化操作从数组中提取的最后字符数。 \\ \hline
is.ignore(streamsize sz=1, int delim=end-of-file) & 忽略sz字符直到delim。                                                   \\ \hline
is.peek()                                         & 从is中获取一个字符，但不使用它。                                     \\ \hline
is.unget()                                        & 将最后一个读取的字符回推到is。                                           \\ \hline
is.putback(ch)                                    & 将字符ch引入流is。                                          \\ \hline
\end{longtable}

\begin{myTip}{std::string有一个getline函数}
std::string的getline函数比istream的getline函数有一个很大的优势,字符串会自动处理它的内存，但必须为is.get(buf, num)所使用的缓冲区保留内存。
\end{myTip}

\begin{cpp}
// inputUnformatted.cpp
...
#include <iostream>
...
std::string line;
std::cout << "Write a line: " << '\n';

std::getline(std::cin, line); // <Only for testing purpose.>
std::cout << line << '\n'; // Only for testing purpose.

std::cout << "Write numbers, separated by;" << '\n';
while (std::getline(std::cin, line, ';') ) {
	std::cout << line << " ";
} // <2000;11;a>
  // 2000 11
\end{cpp}


\mySamllsection{输出}

You can push characters with the insert operator <{}< onto the output stream.

The insert operator <{}<

\begin{itemize}
\item 
is predefined for all built-in types and strings,

\item 
can be implemented for user-defined data types,

\item 
can be adjusted by format specifiers.
\end{itemize}


\mySamllsection{Format Specifier}

Format specifiers enable you to adjust the input and output data explicitly.

\begin{myNotic}{I use manipulators as format specifiers}
The format specifiers are available as manipulators and flags. I only present manipulators in this book because their functionality is quite similar, and manipulators are more comfortable to use.

\filename{Manipulators as format specifiers}

\begin{cpp}
// formatSpecifier.cpp
...
#include <iostream>
...
int num{2011};

std::cout.setf(std::ios::hex, std::ios::basefield);
std::cout << num << '\n'; // 7db
std::cout.setf(std::ios::dec, std::ios::basefield);
std::cout << num << '\n'; // 2011

std::cout << std::hex << num << '\n'; // 7db
std::cout << std::dec << num << '\n'; // 2011
\end{cpp}

\end{myNotic}

The following tables present the important format specifiers. The format specifiers are sticky except for the field width, which is reset after each application.

The manipulators without arguments require the header <iostream>; the manipulators with arguments require the header <iomanip>.

\begin{center}
Displaying of boolean values
\end{center}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|l|}
\hline
\textbf{Manipulator} & \textbf{Stream type} & \textbf{Description}                       \\ \hline
\endfirsthead
%
\endhead
%
std::boolalpha       & input and output     & Displays the boolean as a word.            \\ \hline
std::noboolalpha     & input and output     & Displays the boolean as a number(default). \\ \hline
\end{longtable}

\begin{center}
Set the field width and the fill character
\end{center}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|l|}
\hline
\textbf{Manipulator} & \textbf{Stream type} & \textbf{Description}                            \\ \hline
\endfirsthead
%
\endhead
%
std::setw(val)       & input and output     & Sets the field width to val.                    \\ \hline
std::setfill(c)      & output stream        & Sets the fill character to c (default: spaces). \\ \hline
\end{longtable}



\begin{center}
Alignment of the text
\end{center}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|l|}
\hline
\textbf{Manipulator} & \textbf{Stream type} & \textbf{Description}                                \\ \hline
\endfirsthead
%
\endhead
%
std::left            & output               & Aligns the output left.                             \\ \hline
std::right           & output               & Aligns the output right.                            \\ \hline
std::internal        & output               & Aligns the signs of numbers left, the values right. \\ \hline
\end{longtable}

\begin{center}
Positive signs and upper or lower case
\end{center}


% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|l|}
\hline
\textbf{Manipulator} & \textbf{Stream type} & \textbf{Description}                                    \\ \hline
\endfirsthead
%
\endhead
%
std::showpos         & output               & Displays positive signs.                                \\ \hline
std::noshowpos       & output               & Doesn't display positive signs(default).                \\ \hline
std::uppercase       & output               & Uses upper case characters for numeric values(defulat). \\ \hline
std::lowercase       & output               & Uses lower case characters for numeric values.          \\ \hline
\end{longtable}


\begin{center}
Display of the numeric base
\end{center}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|l|}
\hline
\textbf{Manipulator} & \textbf{Stream type} & \textbf{Description}                             \\ \hline
\endfirsthead
%
\endhead
%
std::oct             & input and output     & Uses natural numbers in octal format.            \\ \hline
std::dec             & input and output     & Uses natural numbers in decimal format(default). \\ \hline
std::hex             & input and output     & Uses natural numbers in hexadecimal format.      \\ \hline
std::showbase        & output               & Displays the numeric base.                       \\ \hline
std::noshowbase      & output               & Doesn't display the numeric base(default).       \\ \hline
\end{longtable}

There are special rules for floating-point numbers:

\begin{itemize}
\item 
The number of significant digits (digits after the comma) is, by default, six.

\item 
If the number of significant digits is not big enough, the number is displayed in scientific notation.
 
\item 
Leading and trailing zeros are not displayed.

\item 
If possible, the decimal point is not displayed.
\end{itemize}


\begin{center}
Floating point numbers
\end{center}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|l|}
\hline
\textbf{Manipulator}   & \textbf{Stream type} & \textbf{Description}                                      \\ \hline
\endfirsthead
%
\endhead
%
std::setprecision(val) & output               & Adjusts the precision of the output to val.               \\ \hline
std::showpoint         & output               & Displays the decimal point.                               \\ \hline
std::noshowpoint       & output               & Doesn't display the decimal point(default).               \\ \hline
std::fixed             & output               & Displays the floating-point number in decimal format.     \\ \hline
std::scientific        & output               & Displays the floating-point number in scientific format.  \\ \hline
std::hecfloat          & output               & Displays the floating-point number in hexadecimal format. \\ \hline
std::defaultfloat & output & Displays the floating-point number in default floating-point notation. \\ \hline
\end{longtable}

\filename{Format specifier}

\begin{cpp}
// formatSpecifierOutput.cpp
...
#include <iomanip>
#include <iostream>
...

std::cout.fill('#');
std::cout << -12345;
std::cout << std::setw(10) << -12345; // ####-12345
std::cout << std::setw(10) << std::left << -12345; // -12345####
std::cout << std::setw(10) << std::right << -12345; // ####-12345
std::cout << std::setw(10) << std::internal << -12345; //-####12345

std::cout << std::oct << 2011; // 3733
std::cout << std::hex << 2011; // 7db

std::cout << std::showbase;
std::cout << std::dec << 2011; // 2011
std::cout << std::oct << 2011; // 03733
std::cout << std::hex << 2011; // 0x7db

std::cout << 123.456789; // 123.457
std::cout << std::fixed;
std::cout << std::setprecision(3) << 123.456789; // 123.457
std::cout << std::setprecision(6) << 123.456789; // 123.456789
std::cout << std::setprecision(9) << 123.456789; // 123.456789000

std::cout << std::scientific;
std::cout << std::setprecision(3) << 123.456789; // 1.235e+02
std::cout << std::setprecision(6) << 123.456789; // 1.234568e+02
std::cout << std::setprecision(9) << 123.456789; // 1.234567890e+02

std::cout << std::hexfloat;
std::cout << std::setprecision(3) << 123.456789; // 0x1.edd3c07ee0b0bp+6
std::cout << std::setprecision(6) << 123.456789; // 0x1.edd3c07ee0b0bp+6
std::cout << std::setprecision(9) << 123.456789; // 0x1.edd3c07ee0b0bp+6

std::cout << std::defaultfloat;
std::cout << std::setprecision(3) << 123.456789; // 123
std::cout << std::setprecision(6) << 123.456789; // 123.457
std::cout << std::setprecision(9) << 123.456789; // 123.456789

\end{cpp}








