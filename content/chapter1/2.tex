由于C++有许多库，为每个用例很难找到最合适的库。

\mySamllsection{实用工具}

实用工具是具有一般性的库，因此可以在许多上下文中应用。

其包括计算最小值或最大值、两个值的中点或交换或移动值的函数。由于保留了整数的比较，所以不会进行整型的类型提升。

其他实用工具有std::function、std::bind或std:bind\_front。使用std::bind或std::bind\_front，可以轻松地从现有函数创建新函数。要将它们绑定到一个变量并在以后调用，可以使用std::function。

使用std::pair和泛化std::tuple，可以创建任意长度的异构对和元组。

引用包装器std::ref和std::cref非常方便。可以使用它们为变量创建引用包装器，而std::cref是常量。

实用工具最实用是智能指针，其允许显式的自动内存管理。可以使用std::unique\_ptr对显式所有权的概念进行建模，并使用std::shared\_ptr对共享所有权进行建模。shared\_ptr使用引用计数来管理其资源。第三个是std::weak\_ptr，这有助于打破std::shared\_ptr之间的循环依赖关系。不过，循环引用是引用计数的经典问题。

类型特征库可以在编译时检查、比较和操作类型信息。

时间库是对C++新多线程功能的重要补充，可以方便地进行性能测量，并包括对日历和时区的支持。

有了std::any、std::optional和std::variant，C++17就有了三种特殊的数据类型。

\mySamllsection{标准模板库}

\myGraphic{1.0}{content/chapter1/images/2.jpg}{STL的三个组成部分}

标准模板库(STL)由三个组件组成。它们是容器，在容器上运行的算法，以及连接两者的迭代器。

容器对其元素只有最小的要求，这种泛型编程能够组合算法和容器。

C++标准库有丰富的容器集合，有顺序容器和关联容器。关联容器可以分为有序关联容器和无序关联容器。

每个序列容器都有惟一的域。尽管如此，95\%的用例中，std::vector是正确的选择。std::vector可以动态调整其大小，自动管理其内存，提供出色的性能。相反，std::array是唯一不能在运行时调整其大小的序列容器，其针对最小的内存和性能开销进行了优化。

虽然std::vector擅长将新元素放在末尾，但应该使用std::deque将元素放在开头。std::list是双链表，std::forward\_list是单链表，我们有两个容器，并针对容器中位置操作进行了优化。

关联容器是键值对的容器。它们通过各自的键提供它们的值。关联容器的典型用例是电话簿，其中使用键姓来检索值电话号码。C++有八种不同的关联容器：其一是带有有序键的关联容器:std::set、std::map、std::multiset和std::multimap。另外，还有无序关联容器:std::unordered\_set、std::unordered\_ map、std::unordered\_multiset和std::unordered\_multimap。

首先，看看有序关联容器。std::set与std::map的区别在于前者没有关联值。std::map和std::multimap的区别在于后者可以有多个相同的键。这些命名约定也适用于无序关联容器，它们与有序容器有很多共同之处，区别在于性能。有序关联容器的访问时间为对数，而无序关联容器的访问时间为常数。因此，无序关联容器的访问时间与它们的大小无关，std::unordered\_map与std::vector适用相同的规则。在95\%的用例中，若不需要排序键，std::unordered\_map应该是首选。

容器适配器为序列容器提供了一个简化的接口。C++有std::stack、std::queue和std::priority\_queue。

支持C-array、std::array、std::vector或std::string视图。span是一个连续元素序列的视图，并且视图永远不是所有者。

迭代器是容器和算法之间的粘合剂。容器创建它们，作为通用指针，可以使用它们向前和向后迭代或跳转到容器中的任意位置。得到的迭代器类型取决于容器。若使用迭代器适配器，就可以直接访问流。

STL为提供了100多个算法。指定执行策略，可以顺序、并行或并行和矢量化地运行大多数算法。算法对元素或一系列元素进行操作。两个迭代器定义一个范围。第一个定义开始，第二个称为end迭代器，定义范围的结束。重要的是要知道，end迭代器指向超出范围末端的一个元素。

该算法具有广泛的应用前景。可以查找元素，对它们进行计数，查找范围，并对它们进行比较或转换。有一些算法可以从容器中生成、替换或删除元素。当然，也可以对容器进行排序、排列或分区，或者确定容器的最小或最大元素。许多算法可以通过函数、函数对象或Lambda函数等可调用对象进一步定制。可调用对象为元素的搜索或转换提供了特殊的标准，极大地提高了算法的能力。

范围库是惰性算法的，可以直接在容器上工作，并且可以很容易地组合，并用函数思想扩展了C++。此外，大多数经典STL算法都具有范围，支持投影并提供额外的安全保证。

\mySamllsection{数值方面}

C++中有两个用于数字的库:随机数库和数学函数，这是C++从C继承来的。

随机数库由两部分组成。有随机数生成器;生成的随机数分布在另一边。随机数生成器生成一个介于最小值和最大值之间的数字流，随机数分布将其映射到具体分布上。

因为C语言，C++有很多数学标准函数。例如，有对数函数、指数函数和三角函数。

C++也支持基本和高级数学常数，如e、π或φ。

\mySamllsection{文本处理}

通过字符串和正则表达式，C++有两个强大的库来处理文本。

std::string拥有丰富的成员函数集合来分析和修改其文本。因为它与字符的std::vector有很多共同之处，所以您可以将STL算法应用于std::string。string是C字符串的继承者，但使用起来更容易、更安全。C++字符串管理它们的内存。

与std::string相比，std::string\_view的复制成本很低。std::string\_view是对std::string的非所属引用。

正则表达式是一种描述文本模式的语言。使用正则表达式确定文本模式在文本中是出现一次还是多次，但这还不是全部。正则表达式支持用文本替换匹配的模式。

\mySamllsection{输入输出}

I/O流库是一个从C++开始就存在的库，可与外部世界进行通信。

这种具体情况下，提取操作符(>{}>)允许它从输入流中读取格式化或未格式化的数据，插入操作符(<{}<)允许将数据写入输出流。数据可以使用操纵符进行格式化。

流类具有复杂的类层次结构。两个流类很重要:首先，字符串流允许与字符串和流交互。其次，文件流能够轻松地读取和写入文件。流的状态保存在可以读取和操作的标志中。

通过重载输入操作符和输出操作符，自定义类可以像基本数据类型一样与外部交互。

格式化库为printf家族提供了一种安全且可扩展的替代方案，并扩展了I/O流库。

与I/O流库相比，文件系统库在C++17中被添加到正式标准中。该库基于三个概念:文件、文件名和路径。文件可以是目录、硬链接、符号链接或普通文件，路径可以是绝对的也可以是相对的。

文件系统库支持一个强大的接口来读取和操作文件系统。

\mySamllsection{多线程}

C++在2011年发布的C++标准中加入了一个多线程库。这个库具有基本的构建块，如原子变量、线程、锁和条件变量，是未来C++标准构建更高抽象的基础。C++11已经在提供比前面提到的基本构建块更高的抽象了。

在底层，C++11首次提供了内存模型和原子变量，这两个组件都是多线程编程中定义良好行为的基础。

C++中的新线程将立即开始工作，其可以在前台或后台运行，并通过复制或引用获取数据。多亏了停止令牌，可以中断改进后的线程std::jthread。

线程之间共享变量的访问必须协调。这种协调可以通过互斥锁或锁的不同方式来完成。通常，保护数据的初始化就足够了，因为它在其生命周期内是不可变的。

将变量声明为线程局部可确保线程获得其副本，因此不会产生冲突。

条件变量是实现发送方-接收方工作流的经典解决方案。关键思想是发送方在完成其工作时通知接收方，以便接收方可以开始工作。

信号量是一种同步机制，用于控制对共享资源的并发访问。信号量有一个大于零的计数器。获取信号量会减少计数器，释放信号量会增加计数器。只有当计数器大于零时，线程才能获取资源。

与信号量类似，std::latch和std::barrier是允许某些线程阻塞直到计数器变为零的协调类型。与std::barrier相反，可以为新的迭代重用std::latch，并为这个新迭代调整它的计数器。

任务与线程有很多共同之处。但当开发者显式地创建线程时，任务将由C++运行时隐式地创建。任务就像数据通道。数据可以是一个值、一个异常，或者只是一个通知。promise将数据放入数据通道，future会带回相应的值。

协程是可以在保持状态的情况下暂停和恢复执行的函数。协程是编写\href{https://en.wikipedia.org/wiki/Event-driven_programming}{事件驱动型应用}的常用方法。事件驱动型应用程序可以是模拟、游戏、服务器、用户界面，甚至是算法。协同程序启用\href{https://de.wikipedia.org/wiki/Multitasking}{协调式多任务}，其处理的关键是每个任务都需要尽可能多的时间。