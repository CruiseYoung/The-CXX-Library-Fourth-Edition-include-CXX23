Using an execution policy in C++17, you can specify whether the algorithm should run sequentially, in parallel, or parallel with vectorization.

\begin{myTip}{Availability of the Parallel STL}
	
In 2023, only the Microsoft Compiler implements the STL algorithm’s parallel version natively. With the GCC or Clang compiler, you have to install and use the \href{https://en.wikipedia.org/wiki/Threading_Building_Blocks}{Threading Building Blocks}. The TBB is a C++ template library developed by Intel for parallel programming on multi-core processors.
\end{myTip}


\mySamllsection{Execution Policies}

The policy tag specifies whether an algorithm should run sequentially, in parallel, or in parallel with vectorization.

\begin{itemize}
\item 
std::execution::seq: runs the algorithm sequentially

\item
std::execution::par: runs the algorithm in parallel on multiple threads

\item
std::execution::par\_unseq: runs the algorithm in parallel on multiple threads and allows the interleaving of individual loops; permits a vectorized version with \href{https://en.wikipedia.org/wiki/SIMD}{SIMD} (Single Instruction Multiple Data) extensions.
\end{itemize}

The following code snippet shows all execution policies.

\filename{The execution policy}

\begin{cpp}
std::vector<int> v = {1, 2, 3, 4, 5, 6, 7, 8, 9};

// standard sequential sort
std::sort(v.begin(), v.end());

// sequential execution
std::sort(std::execution::seq, v.begin(), v.end());

// permitting parallel execution
std::sort(std::execution::par, v.begin(), v.end());

// permitting parallel and vectorized execution
std::sort(std::execution::par_unseq, v.begin(), v.end());
\end{cpp}

The example shows that you can still use the classic std::sort variant without an execution policy. Also, in C++17, you can specify explicitly whether the sequential, parallel, or the parallel and vectorized version should be used.


\begin{myTip}{Availability of the Parallel STL}
	
Whether an algorithm runs in a parallel and vectorized way depends on many factors. For example, it depends on whether the CPU and the operating system support SIMD instructions. Additionally, it depends on the compiler and the optimization level to compile your code.

The following example shows a simple loop for creating a new vector.

\begin{cpp}
const int SIZE= 8;

int vec[] = {1, 2, 3, 4, 5, 6, 7, 8};
int res[] = {0, 0, 0, 0, 0, 0, 0, 0};

int main(){
	for (int i = 0; i < SIZE; ++i) {
		res[i] = vec[i] + 5;
	}
}
\end{cpp}

The expression res[i] = vec[i] + 5 is the critical line in this small example. Thanks to the \href{https://godbolt.org/}{Compiler Explorer}, we can look closely at the assembler instructions generated by x86-64 clang 3.6.

\mySamllsection{Without Optimisation}

Here are the assembler instructions. Each addition is done sequentially.

\myGraphic{0.6}{content/chapter10/images/2.jpg}{}


\mySamllsection{With Maximum Optimisation}

Using the highest optimization level, -O3, special registers such as xmm0 that can hold 128 bits or 4 ‘int’s are used. This means that the addition takes place in parallel on four vector elements.

\myGraphic{0.6}{content/chapter10/images/3.jpg}{}

\end{myTip}

77 of the STL algorithms can be parametrized by an execution policy.

\mySamllsection{Algorithms with parallelized versions}

Here are the 77 algorithms with parallelized versions.

\begin{center}
The 77 algorithms with parallelized versions
\end{center}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{lll}
std::adjacent\_difference       & std::adjacent\_find             & std::all\_of                    \\
\endfirsthead
%
\endhead
%
std::any\_of                    & std::copy                       & std::copy\_if                   \\
std::copy\_n                    & std::count                      & std::count\_if                  \\
std::equal                      & std::exclusive\_scan            & std::fill                       \\
std::fill\_n                    & std::find                       & std::find\_end                  \\
std::find\_first\_of            & std::find\_if                   & std::find\_if\_not              \\
std::for\_each                  & std::for\_each\_n               & std::generate                   \\
std::inner\_product             & std::includes                   & std::inclusive\_scan            \\
std::is\_heap\_until            & std::inplace\_merge             & std::is\_heap                   \\
std::is\_sorted\_until          & std::is\_partitioned            & std::is\_sorted                 \\
std::merge                      & std::lexicographical\_compare   & std::max\_element               \\
std::mismatch                   & std::min\_element               & std::minmax\_element            \\
std::nth\_element               & std::move                       & std::none\_of                   \\
std::partition                  & std::partial\_sort              & std::partial\_sort\_copy        \\
std::remove                     & std::partition\_copy            & std::reduce                     \\
std::remove\_if                 & std::remove\_copy               & std::remov\_copy\_if            \\
std::replace\_copy\_if          & std::replace                    & std::replace\_copy              \\
std::replace\_copy              & std::replace\_if                & std::reverse                    \\
std::reverse\_copy              & std::rotate                     & std::rotate\_copy               \\
std::search                     & std::search\_n                  & std::set\_difference            \\
std::set\_intersection          & std::set\_symmetric\_difference & std::set\_union                 \\
std::sort                       & std::stable\_partition          & std::stable\_sort               \\
std::swap\_ranges               & std::transfrom                  & std::transform\_exclusive\_scan \\
std::transform\_inclusive\_scan & std::transform\_reduce          & std::uninitialized\_copy        \\
std::uninitialized\_copy\_n     & std::uninitialized\_fill        & std::uninitialized\_fill\_n     \\
std::unique                     & std::unique\_copy               &                                
\end{longtable}

\begin{myTip}{constexpr Container and Algorithms}
C++20 supports the constexpr containers std::vector and std::string. constexpr means that you can apply the member functions of both containers at compile time. Additionally, the more than \href{https://en.cppreference.com/w/cpp/algorithm}{100 algorithms} of the Standard Template Library are declared as constexpr.
\end{myTip}














