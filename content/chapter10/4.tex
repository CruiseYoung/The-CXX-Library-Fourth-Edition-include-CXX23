std::for\_each applies a unary callable to each element of its range. The input iterators provide the range.

\begin{cpp}
UnFunc std::for_each(InpIt first, InpIt second, UnFunc func)
void std::for_each(ExePol pol, FwdIt first, FwdIt second, UnFunc func)
\end{cpp}

std::for\_each, when used without an explicit execution policy, is a special algorithm because it returns its callable argument. If you invoke std::for\_each with a function object, you can store the result of the function call directly in the function object.

\begin{cpp}
InpIt std::for_each_n(InpIt first, Size n, UnFunc func) FwdIt std::for_each_n(ExePol pol, FwdIt first, Size n, UnFunc func)
\end{cpp}

std::for\_each\_n is new with C++17 and applies a unary callable to its rangeâ€™s first n elements. An input iterator and a size provide the range.

\filename{std::for\_each}

\begin{cpp}
// forEach.cpp
...
#include <algorithm>
...
template <typename T>
class ContInfo{
public:
	void operator()(T t){
		num++;
		sum+= t;
	}
	int getSum() const{ return sum; }
	int getSize() const{ return num; }
	double getMean() const{
		return static_cast<double>(sum)/static_cast<double>(num);
	}
private:
	T sum{0};
	int num{0};
};

std::vector<double> myVec{1.1, 2.2, 3.3, 4.4, 5.5, 6.6, 7.7, 8.8, 9.9};
auto vecInfo= std::for_each(myVec.begin(), myVec.end(), ContInfo<double>());

std::cout << vecInfo.getSum() << '\n'; // 49
std::cout << vecInfo.getSize() << '\n'; // 9
std::cout << vecInfo.getMean() << '\n'; // 5.5

std::array<int, 100> myArr{1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
auto arrInfo= std::for_each(myArr.begin(), myArr.end(), ContInfo<int>());

std::cout << arrInfo.getSum() << '\n'; // 55
std::cout << arrInfo.getSize() << '\n'; // 100
std::cout << arrInfo.getMean() << '\n'; // 0.55
\end{cpp}

























