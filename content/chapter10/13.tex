
std::prev\_permutation和std::next\_permutation返回新排序范围的前一个较小或下一个较大的排列。若没有更小或更大的排列，则算法返回false。两种算法都需要双向迭代器。默认情况下，使用预定义的排序条件std::less。若使用排序标准，则必须遵守严格的弱排序；否则，程序具有未定义行为。

将前面的排列应用于范围:

\begin{cpp}
bool prev_permutation(BiIt first, BiIt last)
bool prev_permutation(BiIt first, BiIt last, BiPred pre)
\end{cpp}

将下一个排列应用于范围:

\begin{cpp}
bool next_permutation(BiIt first, BiIt last)
bool next_permutation(BiIt first, BiIt last, BiPred pre)
\end{cpp}

可以用这两种算法生成范围的所有排列。

\filename{置换算法}

\begin{cpp}
// permutation.cpp
...
#include <algorithm>
...

std::vector<int> myInts{1, 2, 3};
do{
	for (auto i: myInts) std::cout << i;
	std::cout << " ";
} while(std::next_permutation(myInts.begin(), myInts.end()));
										// 123 132 213 231 312 321

std::reverse(myInts.begin(), myInts.end());
do{
	for (auto i: myInts) std::cout << i;
	std::cout << " ";
} while(std::prev_permutation(myInts.begin(), myInts.end()));
										// 321 312 231 213 132 123
\end{cpp}




















