标准模板库的算法需要一个开始迭代器和一个结束迭代器。

\begin{cpp}
std::vector<int> myVec{1, 2, 3, 4, 5, 6, 7, 8, 9};
auto res = std::accumulate(std::begin(myVec), std::end(myVec), 0);
std::cout << res << '\n'; // 45
\end{cpp}

范围库允许它直接在std::unordered\_map的键(1)或值(3)上创建视图。

\filename{范围直接作用于容器}

\begin{cpp}
// rangesEntireContainer.cpp
...
#include <ranges>

std::unordered_map<std::string, int> freqWord{ {"witch", 25}, {"wizard", 33},
											   {"tale", 45}, {"dog", 4},
											   {"cat", 34}, {"fish", 23} };
std::cout << "Keys" << '\n';
auto names = std::views::keys(freqWord); // (1)
for (const auto& name : names){ std::cout << name << " "; };

for (const auto& na : std::views::keys(freqWord)){ std::cout << na << " "; }; // (2)

std::cout << "Values: " << '\n';
auto values = std::views::values(freqWord); // (3)
for (const auto& value : values){ std::cout << value << " "; };

for (const auto& value : std::views::values(freqWord)){ // (4)
	std::cout << value << " ";
}
\end{cpp}

当然，键和值可以直接显示((2)和(4))。输出是相同的。

\myGraphic{0.5}{content/chapter11/images/2.jpg}{}


























