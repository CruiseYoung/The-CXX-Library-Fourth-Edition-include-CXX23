\myGraphic{0.4}{content/chapter4/images/1.jpg}{Cippi建造堆栈}

\href{http://en.cppreference.com/w/cpp/container}{顺序容器}有很多共同之处，但每个容器都有其特定的域。深入讨论之前，先了解一下std命名空间的五个序列容器。

\begin{center}
顺序容器
\end{center}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|l|l|l|l|}
\hline
\textbf{标准}  & \textbf{array} & \textbf{vector} & \textbf{deque}     & \textbf{list}        & \textbf{forward\_list} \\ \hline
\endfirsthead
%
\endhead
%
大小               & 静态         & 静态         & 动态            & 动态              & 动态                \\ \hline
实现     & 静态数组   & 动态数组   & 数组序列 & 双链表  & 单链表     \\ \hline
访问             & 随机         & 随机          & 随机             & 前向/后向 & 前向                \\ \hline
插入和删除 &
&
末尾: O(1) &
开始和末尾: O(1) &
\begin{tabular}[c]{@{}l@{}}开始和末尾:O(1)\\ 任意位置:O(1)\end{tabular} &
\begin{tabular}[c]{@{}l@{}}开始位置:O(1)\\ 任意位置:O(1)\end{tabular} \\ \hline
内存预留 &                & 是             & 否                 & 否                   & 否                     \\ \hline
内存释放  &                & shrink\_to\_fit & shrink\_to\_fit    & 总是               & 总是                 \\ \hline
优势 &
\begin{tabular}[c]{@{}l@{}}无内存分配;\\ 最低内存要求\end{tabular} &
95\%的方案适用 &
\begin{tabular}[c]{@{}l@{}}开头和结尾\\插入和删除 \end{tabular} &
\begin{tabular}[c]{@{}l@{}}任意位置\\ 插入和删除 \end{tabular} &
\begin{tabular}[c]{@{}l@{}}快速插入和删除;\\ 最低内存要求\end{tabular} \\ \hline
缺点 &
无动态内存分配 &
\begin{tabular}[c]{@{}l@{}}任意位置插入\\ 和删除:O(n) \end{tabular} &
\begin{tabular}[c]{@{}l@{}}任意位置插入\\ 和删除:O(n) \end{tabular} &
无随机访问 &
无随机访问 \\ \hline
\end{longtable}

对于这个表，我还想补充几句。

O(i)表示操作的复杂度(运行时)。O(1)表示容器上操作的运行时间恒定，并且与容器的大小无关。相反，O(n)表示运行时线性依赖于容器元素的数量。对于std::vector意味着什么?元素的访问时间与std::vector的大小无关，但是插入或删除的耗时和位置相关。

std::vector对元素的随机访问与std::deque对元素的随机访问具有相同的复杂度O(1)，但并不意味着这两种操作都一样快。

双链表(std::list)或单链表(std::forward\_list)的插入或删除操作，只有在迭代器指向正确的元素时才能保证复杂度为O(1)。

\begin{myNotic}{std::string就像是std::vector<char>}
当然，std::string不是标准模板库的容器。从行为的角度来看，类似于序列容器，尤其是std::vector<char>，所以我会把std::string视为std::vector<char>。
\end{myNotic}












