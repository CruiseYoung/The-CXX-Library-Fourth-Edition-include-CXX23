访问字符串str的元素非常方便，字符串支持随机访问迭代器。可以使用str.front()访问字符串的第一个字符，并使用str.back()访问字符串的最后一个字符。使用str[n]和str.at(n)，可以根据索引获得第n个元素。

下表提供了一个概述。

\begin{center}
访问字符串的元素
\end{center}

% Please add the following required packages to your document preamble:
% \usepackage{longtable}
% Note: It may be necessary to compile the document several times to get a multi-page table to line up properly
\begin{longtable}[c]{|l|l|}
\hline
\textbf{成员函数} & \textbf{示例}                                                              \\ \hline
\endfirsthead
%
\endhead
%
str.front()               & 返回str的第一个字符。                                           \\ \hline
str.back()                & 返回str的最后一个字符。                                            \\ \hline
std{[}n{]}                & 返回str的第n个字符，不检查边界。 \\ \hline
std.at(n) & 返回str的第n个字符，检查边界。若超出边界，则抛出std::out\_of\_range异常。 \\ \hline
\end{longtable}

\filename{访问元素}

\begin{cpp}
// stringAccess.cpp
...
#include <string>
...

std::string str= {"0123456789"};
std::cout << str.front() << '\n'; // 0
std::cout << str.back() << '\n'; // 9
for (int i= 0; i <= 3; ++i){
	std::cout << "str[" << i << "]:" << str[i] << "; ";
} // str[0]: 0; str[1]: 1; str[2]: 2; str[3]: 3;

std::cout << str[10] << '\n'; // undefined behaviour
try{
	str.at(10);
}
catch (const std::out_of_range& e){
	std::cerr << "Exception: " << e.what() << '\n';
} // Exception: basic_string::at

std::cout << *(&str[0]+5) << '\n'; // 5
std::cout << *(&str[5]) << '\n'; // 5
std::cout << str[5] << '\n'; // 5
\end{cpp}

示例中看到执行str[10]是令人惊讶的行为，因为对于字符串边界之外的访问是未定义行为。相反，当调用str.at(10)时会报错。





























