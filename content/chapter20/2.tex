The following program produces an infinite data stream. The coroutine getNext uses co\_yield to create a data stream that starts at start and gives on request the next value, incremented by step.

\filename{An infinite data stream}

\begin{cpp}
// infiniteDataStream.cpp

...

#include <coroutine>

template<typename T>
struct Generator {
	
	struct promise_type;
	using handle_type = std::coroutine_handle<promise_type>;
	
	Generator(handle_type h): coro(h) {} // (3)
	handle_type coro;
	
	~Generator() {
		if ( coro ) coro.destroy();
	}
	Generator(const Generator&) = delete;
	Generator& operator = (const Generator&) = delete;
	Generator(Generator&& oth) noexcept : coro(oth.coro) {
		oth.coro = nullptr;
	}
	Generator& operator = (Generator&& oth) noexcept {
		coro = oth.coro;
		oth.coro = nullptr;
		return *this;
	}
	T getValue() {
		return coro.promise().current_value;
	}
	bool next() { // (5)
		coro.resume();
		return not coro.done();
	}
	struct promise_type {
		promise_type() = default; // (1)
		
		~promise_type() = default;
		
		auto initial_suspend() { // (4)
			return std::suspend_always{};
		}
		auto final_suspend() noexcept {
			return std::suspend_always{};
		}
		auto get_return_object() { // (2)
			return Generator{handle_type::from_promise(*this)};
		}
		auto return_void() {
			return std::suspend_never{};
		}
		
		auto yield_value(const T value) { // (6)
			current_value = value;
			return std::suspend_always{};
		}
		void unhandled_exception() {
			std::exit(1);
		}
		T current_value;
	};
};

Generator<int> getNext(int start = 0, int step = 1){
auto value = start;
for (int i = 0;; ++i){
	co_yield value;
	value += step;
	}
}

int main() {
	std::cout << '\n';
	
	std::cout << "getNext():";
	auto gen = getNext();
	for (int i = 0; i <= 10; ++i) {
	gen.next();
		std::cout << " " << gen.getValue(); // (7)
	}
	
	std::cout << '\n';
}
\end{cpp}

The main program creates a coroutine. The coroutine gen (7) returns the values from 0 to 10.

\myGraphic{0.6}{content/chapter20/images/2.jpg}{An infinite data stream}

The numbers in the program infiniteDataStream.cpp stand for the first iteration of the workflow.

\begin{enumerate}
\item 
creates the promise

\item 
calls promise.get\_return\_object() and keeps the result in a local variable
 
\item 
creates the generator

\item 
calls promise.initial\_suspend(). The generator is lazy and, therefore, always suspends.

\item 
asks for the next value and returns if the generator is consumed

\item 
triggered by the co\_yield call. The next value is afterward available.

\item 
gets the next value
\end{enumerate}

In additional iterations, only steps 5 and 6 are performed.


